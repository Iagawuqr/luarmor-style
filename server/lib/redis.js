const config=require('../config');const fs=require('fs');const path=require('path');let redis=null,useRedis=false;const DATA_FILE=path.join(__dirname,'..','data','storage.json');const dataDir=path.join(__dirname,'..','data');if(!fs.existsSync(dataDir))fs.mkdirSync(dataDir,{recursive:true});const memoryStore={bans:new Map(),logs:[],challenges:new Map(),cache:new Map(),suspends:new Map(),stats:{success:0,challenges:0,bans:0}};
function loadFromFile(){try{if(fs.existsSync(DATA_FILE)){const data=JSON.parse(fs.readFileSync(DATA_FILE,'utf8'));if(data.bans)Object.entries(data.bans).forEach(([k,v])=>memoryStore.bans.set(k,v));if(data.logs)memoryStore.logs=data.logs.slice(0,1000);if(data.stats)memoryStore.stats=data.stats;if(data.suspends)Object.entries(data.suspends).forEach(([k,v])=>memoryStore.suspends.set(k,v));console.log(`âœ… Loaded ${memoryStore.bans.size} bans, ${memoryStore.suspends.size} suspends from file`)}}catch(e){console.error('Load file error:',e.message)}}
function saveToFile(){try{const data={bans:Object.fromEntries(memoryStore.bans),logs:memoryStore.logs.slice(0,500),stats:memoryStore.stats,suspends:Object.fromEntries(memoryStore.suspends),savedAt:new Date().toISOString()};fs.writeFileSync(DATA_FILE,JSON.stringify(data))}catch(e){console.error('Save file error:',e.message)}}
setInterval(saveToFile,30000);process.on('beforeExit',saveToFile);process.on('SIGINT',()=>{saveToFile();process.exit()});process.on('SIGTERM',()=>{saveToFile();process.exit()});loadFromFile();
async function initRedis(){if(config.REDIS_URL){console.log('ðŸ”„ Connecting to Redis...');try{const Redis=require('ioredis');redis=new Redis(config.REDIS_URL,{maxRetriesPerRequest:3,lazyConnect:true,connectTimeout:10000,tls:config.REDIS_URL.startsWith('rediss://')?{}:undefined});redis.on('error',(err)=>console.error('âŒ Redis error:',err.message));redis.on('close',()=>{console.log('âš ï¸ Redis closed');useRedis=false});await redis.ping();useRedis=true;console.log('âœ… Redis connected!');if(memoryStore.bans.size>0){const existingBans=await redis.hlen('bans');if(!existingBans){console.log('ðŸ“¤ Migrating data to Redis...');for(const[k,v]of memoryStore.bans)await redis.hset('bans',k,JSON.stringify(v));for(const[k,v]of memoryStore.suspends)await redis.set(`suspend:${k}`,JSON.stringify(v));console.log('âœ… Migration complete')}}}catch(e){console.error('âŒ Redis failed:',e.message);console.log('âš ï¸ Using file storage');useRedis=false}}else{console.log('â„¹ï¸ No REDIS_URL, using file storage')}}
initRedis();
async function addBan(key,data){memoryStore.stats.bans++;if(useRedis){try{await redis.hset('bans',key,JSON.stringify(data));await redis.incr('stats:bans');return true}catch(e){console.error('Redis addBan:',e.message)}}memoryStore.bans.set(key,data);saveToFile();return true}
async function removeBan(key){if(useRedis){try{await redis.hdel('bans',key);return true}catch(e){console.error('Redis removeBan:',e.message)}}memoryStore.bans.delete(key);saveToFile();return true}
async function removeBanById(banId){if(useRedis){try{const all=await redis.hgetall('bans');for(const[key,value]of Object.entries(all)){try{const p=JSON.parse(value);if(p.banId===banId){await redis.hdel('bans',key);return true}}catch{}}return false}catch(e){console.error('Redis removeBanById:',e.message)}}for(const[key,value]of memoryStore.bans){if(value.banId===banId){memoryStore.bans.delete(key);saveToFile();return true}}return false}
async function isBanned(hwid,ip,playerId){const keys=[hwid,ip,playerId?String(playerId):null].filter(Boolean);if(keys.length===0)return{blocked:false};if(useRedis){try{for(const key of keys){const data=await redis.hget('bans',key);if(data){try{const p=JSON.parse(data);return{blocked:true,reason:p.reason||'Banned',banId:p.banId}}catch{}}}return{blocked:false}}catch(e){console.error('Redis isBanned:',e.message)}}for(const key of keys){if(memoryStore.bans.has(key)){const d=memoryStore.bans.get(key);return{blocked:true,reason:d.reason||'Banned',banId:d.banId}}}return{blocked:false}}
async function getAllBans(){if(useRedis){try{const all=await redis.hgetall('bans');return Object.values(all).map(v=>{try{return JSON.parse(v)}catch{return null}}).filter(Boolean).sort((a,b)=>new Date(b.ts)-new Date(a.ts))}catch(e){console.error('Redis getAllBans:',e.message)}}return Array.from(memoryStore.bans.values()).sort((a,b)=>new Date(b.ts)-new Date(a.ts))}
async function clearBans(){if(useRedis){try{const all=await redis.hgetall('bans');const count=Object.keys(all).length;if(count>0)await redis.del('bans');return count}catch(e){console.error('Redis clearBans:',e.message)}}const count=memoryStore.bans.size;memoryStore.bans.clear();saveToFile();return count}
async function setChallenge(id,data,ttl=120){memoryStore.stats.challenges++;if(useRedis){try{await redis.setex(`challenge:${id}`,ttl,JSON.stringify(data));await redis.incr('stats:challenges');return true}catch(e){console.error('Redis setChallenge:',e.message)}}memoryStore.challenges.set(id,{...data,expiresAt:Date.now()+(ttl*1000)});return true}
async function getChallenge(id){if(useRedis){try{const data=await redis.get(`challenge:${id}`);if(data){try{return JSON.parse(data)}catch{}}return null}catch(e){console.error('Redis getChallenge:',e.message)}}const data=memoryStore.challenges.get(id);if(data&&data.expiresAt>Date.now())return data;memoryStore.challenges.delete(id);return null}
async function deleteChallenge(id){if(useRedis){try{await redis.del(`challenge:${id}`);return true}catch(e){console.error('Redis deleteChallenge:',e.message)}}memoryStore.challenges.delete(id);return true}
async function addLog(log){if(useRedis){try{await redis.lpush('logs',JSON.stringify(log));await redis.ltrim('logs',0,999);if(log.success)await redis.incr('stats:success');return true}catch(e){console.error('Redis addLog:',e.message)}}memoryStore.logs.unshift(log);if(memoryStore.logs.length>1000)memoryStore.logs=memoryStore.logs.slice(0,1000);if(log.success)memoryStore.stats.success++;return true}
async function getLogs(limit=50){const safeLimit=Math.min(Math.max(1,limit),500);if(useRedis){try{const logs=await redis.lrange('logs',0,safeLimit-1);return logs.map(l=>{try{return JSON.parse(l)}catch{return null}}).filter(Boolean)}catch(e){console.error('Redis getLogs:',e.message)}}return memoryStore.logs.slice(0,safeLimit)}
async function getCachedScript(){if(useRedis){try{return await redis.get('cached_script')}catch(e){console.error('Redis getCachedScript:',e.message)}}const cached=memoryStore.cache.get('script');if(cached&&cached.expiresAt>Date.now())return cached.data;memoryStore.cache.delete('script');return null}
async function setCachedScript(script,ttl=300){if(!script){if(useRedis){try{await redis.del('cached_script')}catch{}}memoryStore.cache.delete('script');return true}if(useRedis){try{await redis.setex('cached_script',ttl,script);return true}catch(e){console.error('Redis setCachedScript:',e.message)}}memoryStore.cache.set('script',{data:script,expiresAt:Date.now()+(ttl*1000)});return true}
async function getStats(){if(useRedis){try{const[success,challenges,bansCount]=await Promise.all([redis.get('stats:success'),redis.get('stats:challenges'),redis.hlen('bans')]);return{success:parseInt(success)||0,challenges:parseInt(challenges)||0,bans:parseInt(bansCount)||0}}catch(e){console.error('Redis getStats:',e.message)}}return{success:memoryStore.stats.success,challenges:memoryStore.stats.challenges,bans:memoryStore.bans.size}}
async function addSuspend(type,value,data){const key=`${type}:${value}`;const entry={...data,type,value,createdAt:new Date().toISOString()};if(useRedis){try{const redisKey=`suspend:${key}`;await redis.set(redisKey,JSON.stringify(entry));if(entry.expiresAt){const ttl=Math.max(1,Math.floor((new Date(entry.expiresAt)-Date.now())/1000));await redis.expire(redisKey,ttl)}return true}catch(e){console.error('Redis addSuspend:',e.message)}}memoryStore.suspends.set(key,entry);saveToFile();return true}
async function removeSuspend(type,value){const key=`${type}:${value}`;if(useRedis){try{await redis.del(`suspend:${key}`);return true}catch(e){console.error('Redis removeSuspend:',e.message)}}memoryStore.suspends.delete(key);saveToFile();return true}
async function getSuspend(type,value){const key=`${type}:${value}`;if(useRedis){try{const data=await redis.get(`suspend:${key}`);if(data){try{return JSON.parse(data)}catch{}}return null}catch(e){console.error('Redis getSuspend:',e.message)}}return memoryStore.suspends.get(key)||null}
async function getAllSuspends(){if(useRedis){try{const keys=await redis.keys('suspend:*');const all=[];for(const key of keys){const data=await redis.get(key);if(data){try{const parsed=JSON.parse(data);all.push(parsed)}catch{}}}return all.sort((a,b)=>new Date(b.createdAt||0)-new Date(a.createdAt||0))}catch(e){console.error('Redis getAllSuspends:',e.message)}}return Array.from(memoryStore.suspends.values()).sort((a,b)=>new Date(b.createdAt||0)-new Date(a.createdAt||0))}
async function clearSuspends(){if(useRedis){try{const keys=await redis.keys('suspend:*');if(keys.length>0)await redis.del(...keys);return keys.length}catch(e){console.error('Redis clearSuspends:',e.message)}}const count=memoryStore.suspends.size;memoryStore.suspends.clear();saveToFile();return count}
setInterval(()=>{if(!useRedis){const now=Date.now();for(const[id,data]of memoryStore.challenges){if(data.expiresAt&&data.expiresAt<now)memoryStore.challenges.delete(id)}for(const[key,data]of memoryStore.suspends){if(data.expiresAt&&new Date(data.expiresAt)<now)memoryStore.suspends.delete(key)}}},60000);
module.exports={addBan,removeBan,removeBanById,isBanned,getAllBans,clearBans,setChallenge,getChallenge,deleteChallenge,addLog,getLogs,getCachedScript,setCachedScript,getStats,isRedisConnected:()=>useRedis,addSuspend,removeSuspend,getSuspend,getAllSuspends,clearSuspends};
